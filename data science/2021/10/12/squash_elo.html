<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Using data to improve professional squash rankings</h1><p class="page-description">Improving the ratings of professional squash players using data and the ELO rating system</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2021-10-12T00:00:00-05:00" itemprop="datePublished">
        Oct 12, 2021
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      8 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/blog/categories/#data science">data science</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#project-overview">Project Overview</a></li>
<li class="toc-entry toc-h2"><a href="#problem-statement">Problem Statement</a></li>
<li class="toc-entry toc-h2"><a href="#metrics">Metrics</a></li>
<li class="toc-entry toc-h2"><a href="#data-exploration">Data Exploration</a></li>
<li class="toc-entry toc-h2"><a href="#data-visualisation">Data Visualisation</a></li>
<li class="toc-entry toc-h2"><a href="#data-preprocessing">Data Preprocessing</a></li>
<li class="toc-entry toc-h2"><a href="#implementation">Implementation</a></li>
<li class="toc-entry toc-h2"><a href="#refinement">Refinement</a></li>
<li class="toc-entry toc-h2"><a href="#results">Results</a></li>
<li class="toc-entry toc-h2"><a href="#reflection">Reflection</a></li>
<li class="toc-entry toc-h2"><a href="#improvement">Improvement</a></li>
</ul><h2 id="project-overview">
<a class="anchor" href="#project-overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Project Overview</h2>
<p>Using the ELO rating system and past few decades of squash match data, I created ratings that are superior to the current simplistic ratings used by the Professional Squash Association (PSA). Code for this project is available in the <a href="https://github.com/Lovkush-A/squash_elo">GitHub repository for this project</a>.</p>

<h2 id="problem-statement">
<a class="anchor" href="#problem-statement" aria-hidden="true"><span class="octicon octicon-link"></span></a>Problem Statement</h2>
<p>There are two big problems in the current way squash ratings are determined by PSA.</p>

<ol>
  <li>
    <p>A player gets rating points depending on which tournment they play in and which round they reach in the tournament. There is zero weight put on who you actually play against. E.g. it ought to be more impressive to beat the world’s best player in Round 1, then to reach a quarter-final by beating low ranked players (because you had a lucky draw).</p>
  </li>
  <li>
    <p>The current rating points are not meaningful. It is revealing that ratings point are never mentioned in squash broadcasts.</p>
  </li>
</ol>

<p>The proposed strategy is to use the ELO rating system.
The underlying ideas behind ELO are straightforward:</p>
<ul>
  <li>Use the difference between ratings of players to compute an expected score for an individual match.</li>
  <li>Changes in ratings after an individual match are proportional to the difference between the true score and the expected score.</li>
</ul>

<p>The full details are as follows:</p>

<ul>
  <li>If two players have ratings <code class="highlighter-rouge">r1</code> and <code class="highlighter-rouge">r2</code> respectively, then the predicted odds of player 1 beating player 2 is <code class="highlighter-rouge">p(r1, r2) = 1 / (1 + 10**((r2 - r1) / 400))</code>
    <ul>
      <li>Note there is nothing fundamentally important about the numbers 10 or 400 here. These are simply the numbers used in chess, the most famous use case of the ELO rating system.</li>
      <li>And yes, this is just (a scaled version) of the sigmoid function!</li>
    </ul>
  </li>
  <li>If Player 1 with rating <code class="highlighter-rouge">r1</code> beats Player 2 with rating <code class="highlighter-rouge">r2</code>, then the ratings are updated as follows:
    <ul>
      <li>The change in rating is <code class="highlighter-rouge">delta = K*(1 - p(r1, r2))</code>.
        <ul>
          <li>The variable <code class="highlighter-rouge">K</code> is a hyper-parameter. The larger <code class="highlighter-rouge">K</code> is, the bigger the changes in ratings will be.</li>
          <li>The quantity <code class="highlighter-rouge">1-p(r1, r2)</code> is the difference between the true score of 1 (representing victory) and predicted score of <code class="highlighter-rouge">p(r1, r2)</code>.</li>
        </ul>
      </li>
      <li>Player 1’s new rating is <code class="highlighter-rouge">r1+delta</code>
</li>
      <li>Player 2’s new rating is <code class="highlighter-rouge">r2-delta</code>
</li>
    </ul>
  </li>
  <li>If a player has not yet played any matches, we assign them a default starting rating of 1500.
    <ul>
      <li>This is arbitrary, since ELO ratings only depend on differences in ratings.</li>
    </ul>
  </li>
</ul>

<p>And that’s it!</p>

<p>By construction, ELO gaurantees to fix problem 1 because the ratings are completely based on who you beat, rather than which round of a tournament you reach.</p>

<p>However, the second problem is not guaranteed to be fixed by ELO, and will require empirical verification. This leads on to the metrics used to evaluate ELO.</p>

<h2 id="metrics">
<a class="anchor" href="#metrics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Metrics</h2>
<p>We evaluate ELO by computing the following ‘calibration metric’ for various values of <code class="highlighter-rouge">p</code>:</p>

<ul>
  <li>In all the matches in which the ELO rating system predicts that the higher-rated player has probability <code class="highlighter-rouge">p</code> of winning, what is the true rate at which the higher-rated player actually wins.</li>
</ul>

<p>For example, if the ELO rating system believes that the higher rated player has 70% odds of winning, then we should observe the higher rated player winning approximately 70% of the time.</p>

<p>These calibration metrics provide a measure of how well (or not) a rating system can fix problem 2.</p>

<h2 id="data-exploration">
<a class="anchor" href="#data-exploration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Exploration</h2>
<p>The raw data I used contains the male match history from the past few decades. It includes players’ names, their seed for the tournament, who won the match, the scores of the games in the match (usually) and some other minor details.</p>

<p>Here are a few entries from the dataframe to illustrate:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">tournament_index</th>
      <th style="text-align: right">round</th>
      <th style="text-align: right">players</th>
      <th style="text-align: right">result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">0</td>
      <td style="text-align: right">Quarter-finals</td>
      <td style="text-align: right">[1] Tayyab Aslam (PAK) bt Farhan Hashmi (PAK)</td>
      <td style="text-align: right">7-11, 11-9, 11-5, 11-5 (32m)</td>
    </tr>
    <tr>
      <td style="text-align: right">0</td>
      <td style="text-align: right">Quarter-finals</td>
      <td style="text-align: right">[7] Israr Ahmed (PAK) bt [9/16] Waqas Mehboob …</td>
      <td style="text-align: right">11-3, 11-3, 11-8 (23m)</td>
    </tr>
    <tr>
      <td style="text-align: right">0</td>
      <td style="text-align: right">Quarter-finals</td>
      <td style="text-align: right">[4] Amaad Fareed (PAK) bt [5] Farhan Zaman (PAK)</td>
      <td style="text-align: right">11-8, 11-7, 12-10 (25m)</td>
    </tr>
  </tbody>
</table>

<p>Not all of the data in this dataframe was needed for the project and there was a little bit of dirty data. Here are the cleaning and feature extraction steps taken:</p>
<ul>
  <li>Dropping columns that were not useful for the analysis (<code class="highlighter-rouge">round</code> and <code class="highlighter-rouge">tournament_index</code>).</li>
  <li>Extracting the score in games from the score in points provided in the <code class="highlighter-rouge">result</code> column. In retrospect, this was not needed for the project, but it is still useful if I want to extend the project to make use of games scores. See possible improvements below.</li>
  <li>Keeping only those rows in which one player beat another player and dropping all other rows.
    <ul>
      <li>The vast majority of rows dropped were because a player automatically gets through in a particular round. E.g. if there are 48 players in a tournament, then in Round 1, players seeded 1 to 16 will automatically get through to Round 1 without having to beat anybody.</li>
      <li>There were exactly two other rows that got dropped. One is recorded as “No shows” and the other is recorded as “Final not played due to unsafe court conditions.”</li>
    </ul>
  </li>
  <li>Parsing the <code class="highlighter-rouge">players</code> column of the raw data.
    <ul>
      <li>Extract the name (and seed and country) of the winner and loser of the match.</li>
      <li>This was done using regex. If you are interested, the regex patterns used are in the <code class="highlighter-rouge">parse_player_entry</code> function in the <a href="https://github.com/Lovkush-A/squash_elo/blob/main/notebooks/01-la-processing.ipynb">processing notebook</a>.</li>
    </ul>
  </li>
</ul>

<p>At the end of this exploration, cleaning and feature extraction, the key information we end up with is a dataframe with two columns (name of winner and name of loser) where each row is a single match, and it is ordered chronologically.</p>
<h2 id="data-visualisation">
<a class="anchor" href="#data-visualisation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Visualisation</h2>
<p>As far as I know, there are no data visualisations that help with the next task of calculating ELO ratings. If you run the <a href="https://github.com/Lovkush-A/squash_elo/blob/main/notebooks/01-la-processing.ipynb">processing notebook</a>, you will see some visuals (e.g. showing distribution of players’ win percentages) but they have no influence on the next steps.</p>

<h2 id="data-preprocessing">
<a class="anchor" href="#data-preprocessing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Data Preprocessing</h2>
<p>This has already been discussed in the data exploration section above.</p>

<h2 id="implementation">
<a class="anchor" href="#implementation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation</h2>
<p>The code to calculcate the ELO rating systems is in the <a href="https://github.com/Lovkush-A/squash_elo/blob/main/notebooks/02-la-analysis.ipynb">analysis notebook</a>.</p>

<p>Surprisingly, there were minimal complications in the implementation of the ELO rating system. I just had to write functions that calculate how to update ELO ratings based on a single match, then loop through all matches and update ELO ratings one-by-one.</p>

<p>One implementation detail worth noting is how I chose an initial value for the hyper-parameter <code class="highlighter-rouge">K</code> (see problem statement section). The choice was based on the values used in chess (the most famous place ELO ratings are used) and they are given in the <a href="https://en.wikipedia.org/wiki/Elo_rating_system#Mathematical_details">wikipedia article on ELO rating system</a>.</p>

<h2 id="refinement">
<a class="anchor" href="#refinement" aria-hidden="true"><span class="octicon octicon-link"></span></a>Refinement</h2>
<p>The refinement process was straightforward: I simply tried various values for the hyper-parameter <code class="highlighter-rouge">K</code> and looked at how their values in the ‘calibration metrics’ compared. The first solution tried used <code class="highlighter-rouge">K=32</code> and the final solution uses <code class="highlighter-rouge">K=100</code>.</p>

<h2 id="results">
<a class="anchor" href="#results" aria-hidden="true"><span class="octicon octicon-link"></span></a>Results</h2>

<p>Here is table of ‘calibration metrics’ for <code class="highlighter-rouge">K=32</code>:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Predicted probability of higher &lt;/br&gt;rated player winning.&lt;/br&gt; Rounded to nearest 0.05</th>
      <th style="text-align: right">Number of predictions</th>
      <th style="text-align: right">Observed fraction of matches that &lt;/br&gt;higher rated player won</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">0.50</td>
      <td style="text-align: right">7386</td>
      <td style="text-align: right">0.466152</td>
    </tr>
    <tr>
      <td style="text-align: right">0.55</td>
      <td style="text-align: right">11801</td>
      <td style="text-align: right">0.566647</td>
    </tr>
    <tr>
      <td style="text-align: right">0.60</td>
      <td style="text-align: right">9542</td>
      <td style="text-align: right">0.657514</td>
    </tr>
    <tr>
      <td style="text-align: right">0.65</td>
      <td style="text-align: right">8010</td>
      <td style="text-align: right">0.746067</td>
    </tr>
    <tr>
      <td style="text-align: right">0.70</td>
      <td style="text-align: right">6759</td>
      <td style="text-align: right">0.803817</td>
    </tr>
    <tr>
      <td style="text-align: right">0.75</td>
      <td style="text-align: right">5772</td>
      <td style="text-align: right">0.867983</td>
    </tr>
    <tr>
      <td style="text-align: right">0.80</td>
      <td style="text-align: right">4967</td>
      <td style="text-align: right">0.900946</td>
    </tr>
    <tr>
      <td style="text-align: right">0.85</td>
      <td style="text-align: right">4062</td>
      <td style="text-align: right">0.932546</td>
    </tr>
    <tr>
      <td style="text-align: right">0.90</td>
      <td style="text-align: right">3128</td>
      <td style="text-align: right">0.953005</td>
    </tr>
    <tr>
      <td style="text-align: right">0.95</td>
      <td style="text-align: right">2112</td>
      <td style="text-align: right">0.974905</td>
    </tr>
    <tr>
      <td style="text-align: right">1.00</td>
      <td style="text-align: right">369</td>
      <td style="text-align: right">0.981030</td>
    </tr>
  </tbody>
</table>

<p>The pattern here is that the predicted odds of winning are underconfident: if the ELO rating thinks that the higher-rated player has 80% odds of winning, they actually win 90% of the time.
My instinct was that the ELO rating was not updating quick enough based on the data, i.e. that <code class="highlighter-rouge">K</code> is too small.
But I was not 100% sure of this, so I did some (basic and manual) hyperparameter tuning, creating a function that loops through several values of <code class="highlighter-rouge">K</code> (namely 10, 50, 100, 200 and 500).</p>

<p>Manually looking at the tables shows that <code class="highlighter-rouge">K</code> = 100 is the best value out of these. Here are the values for the calibration metrics we get:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Predicted probability of higher rated player winning. Rounded to nearest 0.05</th>
      <th style="text-align: right">Number of predictions</th>
      <th style="text-align: right">Observed fraction of matches that higher rated player won</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">0.50</td>
      <td style="text-align: right">2566</td>
      <td style="text-align: right">0.518316</td>
    </tr>
    <tr>
      <td style="text-align: right">0.55</td>
      <td style="text-align: right">5315</td>
      <td style="text-align: right">0.559548</td>
    </tr>
    <tr>
      <td style="text-align: right">0.60</td>
      <td style="text-align: right">5292</td>
      <td style="text-align: right">0.611678</td>
    </tr>
    <tr>
      <td style="text-align: right">0.65</td>
      <td style="text-align: right">5238</td>
      <td style="text-align: right">0.668385</td>
    </tr>
    <tr>
      <td style="text-align: right">0.70</td>
      <td style="text-align: right">5401</td>
      <td style="text-align: right">0.700796</td>
    </tr>
    <tr>
      <td style="text-align: right">0.75</td>
      <td style="text-align: right">5642</td>
      <td style="text-align: right">0.755583</td>
    </tr>
    <tr>
      <td style="text-align: right">0.80</td>
      <td style="text-align: right">6024</td>
      <td style="text-align: right">0.813081</td>
    </tr>
    <tr>
      <td style="text-align: right">0.85</td>
      <td style="text-align: right">6507</td>
      <td style="text-align: right">0.849393</td>
    </tr>
    <tr>
      <td style="text-align: right">0.90</td>
      <td style="text-align: right">7258</td>
      <td style="text-align: right">0.900248</td>
    </tr>
    <tr>
      <td style="text-align: right">0.95</td>
      <td style="text-align: right">8834</td>
      <td style="text-align: right">0.937967</td>
    </tr>
    <tr>
      <td style="text-align: right">1.00</td>
      <td style="text-align: right">5831</td>
      <td style="text-align: right">0.967930</td>
    </tr>
  </tbody>
</table>

<p>You can see that the predictions are well callibrated!</p>

<h2 id="reflection">
<a class="anchor" href="#reflection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reflection</h2>
<p>I personally find these results astonishing. By using a straightforward rule to update players’ ratings based on their old ratings, we are able to get a meaningful rating system that provides callibrated odds on who will win a match.</p>

<p>I was not expecting this at all! Before doing the project, I was anticipating having to tweak the algorithm (e.g. by including some ‘domain knowledge’ somehow), but the ELO rating system just worked out-of-the-box. It is always nice when things simply work out!</p>

<h2 id="improvement">
<a class="anchor" href="#improvement" aria-hidden="true"><span class="octicon octicon-link"></span></a>Improvement</h2>
<p>There are numerous ways this project could be improved or extended. Here are just a few possibilities:</p>

<ul>
  <li>Automatically update ratings as new results come in, by scraping live match data.</li>
  <li>Create a web app with these squash ratings. Allow users to see predictions for upcoming matches and tournaments, and explore past data.</li>
  <li>Currently we only use the final result of the match. However, we should be able to use the score in games to improve the ratings: winning 3-0 is more impressive than winning 3-2 and that should be reflected in the update rule. The way to do this is to have more refined definition of ‘true score’. Right now true score is 1 for victory, but can imagine having true score of 0.9 for winning 3-0 and true score of 0.7 for winning 3-2. This would require some tuning.</li>
  <li>Creating a general purpose ELO-rating package that people can use to create ELO ratings and predictions for any sports or competitions they are interested in.</li>
</ul>


  </div><a class="u-url" href="/blog/data%20science/2021/10/12/squash_elo.html" hidden></a>
</article>