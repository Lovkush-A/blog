---
toc: true
layout: post
description: The process I used to make the animations was inefficient and not programmatic. I could not work out how to adapt the matplotlib animation tools to my situation so I asked for help. Here I describe what I learnt from the help that I received.
categories: [data science, python]
title: Visualising L1 and L2 regularisation, Part II, Lessons learnt from an experienced programmer
---
## Other posts in series
{% for post in site.posts %}
{% if (post.title contains "L1 and L2") and (post.title != page.title) %}
* [{{ post.title }}]({{ site.baseurl }}{{ post.url }})
{% endif %}
{% endfor %}

## Introduction
In the first post in this series, I produced various animations to help visualise L1 vs L2 regularisation. However, the way I produced those animations was not 100% programmatic. This is what I did:
* Have a for loop which produces each chart then saves it as a png file.
* Manually use an online gif tool to combine the png files.

However, I knew it was possible to create a video programmatically in matplotlib, as I had done it before to [visualise gradient descent]({% post_url 2020-09-10-sgd1.md %}). But I could not work out how to adapt the functions to this case.  Therefore, I decided to ask for help in the Faculty Slack channel. I got two helpful responses.

* One by Will Fawcett which told me about the command line tool `convert` that can create the gifs
* Second by Tom Begley who recommended using `FFMpegWriter`. Furthermore, he actually created a pull request in which he adapted my code to illustrate how to use it!

This was the first time I had asked for help in the general Slack channel, so I was taken aback by the help that was provided.

Anyway, in the pull request, in addition to illustrating how to use `FFMpegWriter`, there were various other little things that were changed and things I could learn from. Therefore, I am writing this blogpost to maximise how much I learn from the experience.

## Lessons learnt
### Automatic code formatting for notebooks
A noticeable change in the pull request was that many of the changes concerned code formatting. BBelow is an example.

Before:
```python
def create_cost_fn(centre_x, centre_y, reg=None,  reg_const=0):
    """
    returns a convex cost function
    """
    if reg is None:
        def cost(x,y):
            return (x - centre_x)**2 + (y - centre_y)**2
    elif reg == 'l1':
        def cost(x,y):
            return (x - centre_x)**2 + (y - centre_y)**2 + reg_const*(abs(x) + abs(y))
    elif reg == 'l2':
        def cost(x,y):
            return (x - centre_x)**2 + (y - centre_y)**2 + reg_const*(x**2 + y**2)
    elif reg == 'max':
        def cost(x,y):
            return (x - centre_x)**2 + (y - centre_y)**2 + reg_const*(x**10 + y**10)**0.1

    return cost
```

After:
```python
def create_cost_fn(centre_x, centre_y, reg=None, reg_const=0):
    """
    returns a convex cost function
    """
    if reg is None:

        def cost(x, y):
            return (x - centre_x) ** 2 + (y - centre_y) ** 2

    elif reg == "l1":

        def cost(x, y):
            return (
                (x - centre_x) ** 2
                + (y - centre_y) ** 2
                + reg_const * (abs(x) + abs(y))
            )

    elif reg == "l2":

        def cost(x, y):
            return (
                (x - centre_x) ** 2
                + (y - centre_y) ** 2
                + reg_const * (x ** 2 + y ** 2)
            )

    elif reg == "max":

        def cost(x, y):
            return (
                (x - centre_x) ** 2
                + (y - centre_y) ** 2
                + reg_const * (x ** 10 + y ** 10) ** 0.1
            )

    return cost
```

I knew there was no way Tom did this manually so surmised he used an automatic code formatter. A quick Google search revealed various options and I will be sure to make use of these in the future.

### Decorators
I already knew about decorators, but somehow never thought of making use of them.

Before:
```python
def create_y_l1_coordinate(x, r):
...
create_y_l1_coordinates = np.vectorize(create_y_l1_coordinate)
```

After:
```python
@np.vectorize
def create_y_l1_coordinate(x, r):
...
```

## Github Repository
Here is the link to the [Github repository](https://github.com/Lovkush-A/l1l2_regularisation) in case you're interested in looking at the full code and comparing things for yourself.
